* 札幌 Java カンファレンス 2012 に参加した
僕にとっては新しく知った話があり，とても勉強になりました．

すでに感覚としてぼんやりと認識していた話もありましたが，話者が整理して再構築してくださったことで，認識をクリアにすることができ，これもまたとても勉強になりました．

良い刺激になりました．ありがとうございます．

次回は IntelliJ 入門があるといいなあと思いました．
Eclipse と NetBeans は使ってみたことがあるのですが，IntelliJ は半日程度試してみたものの，使い方があまりわからず断念した経緯があります．

* Lambda への道 - @skrb
Java の lamda について，
外部のローカル変数に再代入できないのは，
大体の場合 reduce があれば大丈夫なので平気です．
1 行のときだけ特別扱いする記法があるのも
細かい粒度での記述のモチベーションになるので悪くないなあと思いました．

もし，JVM 系言語で開発するなら，僕の場合のファーストチョイスは JRuby になりますけど，
他の選択肢としては，今のところ Java8 >> Groovy > Java7 以前という順番になりそうです．

Java8 早く出ないかなあ．

以下はメモです

** BackGround - なぜ lambda が必要とされているのか

- Closure for Java7 @2005JavaOne
- BGGA @2006
- 入れるー入れないで大激論
- (収集がつかないので)Closure 中止 @2008Devoxx
- Project Lambda@2009Devoxx

2008 年に中止したのに 2009 年にすぐ復活している．なぜ lambda が必要とされているのか
-> 2000 年代後半から multicore が隆盛

- Fine Grained Parallelism
  - 実は JavaSE7 に Fork/Join Framework というのが入ってる
  - あんまり使い所がない...

- Iterator
 - Internal Iterator
 - External Iterator
- Internal Iterator を採用 -> 細粒度かつ(変数の受け渡しがなければ)独立

- Functional Interface
  - 実装すべきメソッドが1つだけのインタフェース

- Lambda Expression
  - 関数型インタフェースを実装した無名クラスのインタンシエーション記法

** Lambda Syntax - Lambda の記法

#+begin_src
(引数, 引数) -> { 処理 }

interface Adder { int add(int x, int y); }
Adder adder1 = (int x, int y) -> { return x + y; };
// 引数の方を省略
Adder adder2 = (x, x) -> { return x + y; };
// 処理が 1 行であれば波カッコと return を省略
Adder adder3 = (x, y) -> x + y;

interface Doubler { int doubleUp(int x); }
// 引数が 1 つであれば，カッコも省略可
Doubler doubler = x -> x + x;
#+end_src

- クロージャー「ではない」とは
  - ローカル変数への
    - 代入
      - ブロックの外側の変数に再代入できない
    - 参照
      - final ついたローカル変数じゃないとアクセスできない
      - 再代入しないなら，実質 final なので，final を省略できる(みなしfinal)

*** Default Method

#+begin_src
interface Hello {
    void sayHello(String name);

    void sayGoodbye(String name) default {
        System.out.println("Goodbye, " + name + "!");
    }
}
#+end_src

** Iterator - イテレーターAPI

*** Stream
#+begin_src
List<String> list = ...;
list.forEach(element -> System.out.println(element));

Stream<T> filter(Predicate<? super T> predicate)
Stream<T> sorted(Comparator<? super T> comp)
Stream<U> map(Mapper<? super T, ? extends U> m)
T reduce(T base, BinaryOperator<T>, reducer)
#+end_src

*** Bulk Operation
#+begin_src
// Shape のうち，青い色の合計重量を求めよう
List<Shape> shapes = ...
int sum = 0;

for (Shape shape: shapes) {
  if (shape.getColor() == Color.BLUE) {
    sum += shape.getWeight();
  }
}

// lambda で書いてみる
// フィルタリング処理 + マッピング処理 + 合計処理
int sum
= shapes.stream()
        .filter(s->s.getColor()==Color.BLUE)
        .map(s -> s.getWeight())
        .reduce(0, (l, r) -> l + r);

// 並列処理してくれる
int sum
= shapes.parallel()
        .filter(s->s.getColor()==Color.BLUE)
        .map(s -> s.getWeight())
        .reduce(0, (l, r) -> l + r);
#+end_src

** 現状

- Lambda Syntax // fixed
- Iteration API // いまこっちがんばってる

Developer Preview は http://jdk8.java.net/lambda にあるよ

* 作って学ぶデータベース - @kis
自分でももしかしたら DB を作れるかもしれないと思うような内容で，ぜひやってみたいと思いました．
特に自分でトランザクションを実装できれば，自分の自信になりそう．ついでにもしかしたら業務アプリケーションの承認フローの実装の役に立つかもしれません．

プレゼンの絵が斬新だったのと，写真のヒヨコがかわいかったです．

ただし，後でお話を伺ったら，実装は 10 日でできてますけど，作るための知識を得るのにはもうちょっと時間がかかっているみたいでした．

以下はメモです

- "みなさんデータベースの一つや二つは実装してますよね"
- "みなさん postgres や mysql のソースは読んでるじゃないですか"

** 作ったもの
*** day1 - 基本
リレーショナルモデルの実装 300行くらい

- リレーショナル演算
  - 選択 where
  - 射影 select
  - 結合 join
  - 和 uion

*** day2 - サブクエリと構造変更
*** day3 - 集計
600 行いかないくらい
*** day4 - インデックス
山場

- インデックス
  - ツリーインデックス
  - ハッシュインデックス

*** day5 - 集計でのインデックス
*** day6 - 更新・削除
*** day7 - ユニオン
SQLで直接は書いてないんだけど，DBが裏で使いまくってるんだぜ．

kubun = 5 OR price > 1000

*** day8 - insert時のトランザクション
*** day9 - MVCC
- マルチバージョン同時実行制御
  - データにバージョン番号をつける(今のクエリは何番まで見えるか)
  - コンテキストの導入
  - 古い更新データの保存
*** day10 - 隔離レベル
1700 行くらい

上から下に隔離レベルが上がっていく

| Read Uncommited | 未コミットの操作も見える                       | MVCCだと，バージョンを指定しなければこれになる                                     |
| Read Commited   | コミットした操作は見えちゃう                   | MVCCだと，読むときにバージョン番号を判断する所で，バージョンを無視すればこれになる |
| Repeatable Read | コミットした追加・削除は見える，更新は見えない | 理解不能なのでやらなかった                                                         |
| Serializable    | トランザクション開始時のデータしか見えない     | MVCCだと，もうできてる                                                             |


** 作りたいもの
*** クエリと実行計画
- パーサーをどうする
  - JavaCCとかめんどい
  - Scalaで書く
  - 簡単なPEGパーサーを作る
*** 実行時最適化
*** ストレージとログ
*** Join戦略
- ネストループ結合
- ソートマージ結合
- インデックスを使った結合

複数の戦略が使えるときにどうするか
- ルールベース
  - 状況別の優先順位を決めておく
- コストベース
  - 処理時間やデータ分布などの統計情報を得ておく
*** JDBC対応
- めんどくさそう
- 並列実行
  - ロックが必要
*** ロック
- 今はなにもしてない
- 今後書きこみロックはあったほうがいいと考えている
- インデックスのロック
  - BTreeとロック
*** デッドロック
- 簡単なのはn秒待ってabort
*** まとめ
- 実行エンジン以降はNoSQLでも重要
- RDBMSの実行時最適化はNoSQLでも使える

- 参考文献
  - DatabaseManagementSystems
  - "RDBMS解剖学" という本を後から見つけた．おすすめ

* 顧客とPMとPGの話は，なぜ噛み合わないのか - @yusuke_arclamp
僕の行動原理を振りかえってみると "Do the right thing" のことばかり考えていて，"Do things right" について主で考えたことはなかったですねえ．
"Do the right thing" するために "Do things right" が必要なのだと思っていた．実施についてもうちょっと考えてもいいのかな．

物事を整理して説明してくださった前半と，選択する責任と覚悟の話をなさっていた後半 ( というか最後 ) の対比が印象深かったです．

前半の話は、プロジェクトの当事者でなくてもできる、プロジェクト一般について語られている話でした。
もちろんそれがないと、どの方向に進めていいかわからなくなるので必要です。いわば地図ですね。

後半の話は、プロジェクトの当事者でなくてはできない、プロジェクトを進めるための話でした。
みんなで「うーん、どうしよう」と考えているだけではプロジェクトは動かないですね。
「こういう事情を勘案して、今回はこれでいく。責任は俺が取る」と言う人がいてはじめてプロジェクトはうまく動けるのかもしれません。

以下はメモです

** 次の案件にはどのフレームワークを採用しますか？
- (伝統の)Struts
- (標準の)JavaEE6
- (革新の)PlayFramework
- なんでもいい

決めたとき，どの立場で考えていましたか

- PM
- 技術リーダー
- 保守リーダー
- 顧客

他の立場に立つと選択は変わるかもしれない

** ソフトウェア開発とは
ソフトウェア品質モデル(JISX0129-1ソフトウェア製品の品質 第1部 品質モデル)

1. プロセス品質
2. 内部品質
3. 外部品質
4. 利用時の品質

品質は1->4へ影響を与えるし，4->1へ依存する．

- 利用時の品質は，使う人によって異なる(複数の評価軸がある)
- 外部品質は仕様
- 内部品質はソフトウェアの中身(クラス設計とか基本設計書とか，バージョン管理しているかとか)
- プロセス品質は，作業の一連の流れ(コミュニケーションとか，作業フローとか)
  - 後に残らない

- ソフトウェア開発は上記の品質のバランスを取ることが大事になる
- ソフトウェア開発の失敗は，これらの依存/影響関係が壊れていること

どうやったら良い依存/影響関係を築けるだろうか

** プロジェクトマネジメントとは
- PMBOK
  - 5つのプロセス
    - 立ち上げ
    - 計画
    - コントロール
    - 遂行
    - 終結
  - 9つのナレッジ定義

プロジェクトマネジメントをざっくり言うと計画・実行・調整をしている

- プロジェクトでの事故原因は2つ
  1. 計画の問題
  2. 実行の問題

PMBOK は計画と実行の差を把握するための知識群

PMは「計画と実行の差」から「課題を予測/予知」し「調整」を行うことで，プロジェクトを正しい状態に導くことが必要

** アーキテクチャとは
- システムはある環境にいて，あるミッションを達成しなければならない
- システムにはさまざまな利害関係者がいる
- 利害関係者はそれぞれ関心事がある(ビューポイント)
- それぞれのビューポイントを調整した結果がアーキテクチャ

アーキテクチャ設計とは，システムのミッションと制約を前提に利害関係者の関心事を整合させた

** アーキテクチャとマネジメント
- マネジメントってプロセス品質を考える人のこと？ -> ちがうよ
- アーキテクチャって内部品質を考える人のこと？ -> ちがうよ

どちらも，品質同士の依存/影響関係に注目している人のことだよ．

| 役割                     | 主題               | いつ活動するか                                                                   |
| プロジェクトマネジメント | 問題の予測と対応   | 事後的な活動(対応)がメイン．計画段階はアーキテクトと協業                         |
| アーキテクチャ設計       | 問題対応能力の確保 | 事前的な活動(計画)がメイン．事後はプロジェクトマネジメントへの技術的な支援をする |

- どうやって協業するの？
  - WBSを通してやったらいいと思う
  - WBSのたたき台はアーキテクトが作った方がいい(技術的な物事を割り当てるのは技術がわかる人がやった方がいい)
    - 調整はマネジメントと一緒にやる
- 誰が，その役割を果たすべきか
  - マネジメントは必ずしもPMだけのものではない
  - アーキテクチャ設計は必ずしもアーキテクトだけのものではない

"不満をいくらtwitterに書いてもプロジェクトは好転しないので"

- マネージャー「Do things right」物事をうまくやろう
- リーダー「Do the right thing」良いことをやろう

*** どうやってバランスを取るか
内圧と外圧のバランスを取り，張りを維持する

- 外圧(使うこと)
  - ビジョン
  - 要求
  - 要件
  - 制約
- 内圧(作ること)
  - 戦術
  - 設計
  - 実装
  - ミッション

** まとめ
- 4 つの品質の依存/影響関係をつくろう
- アーキテクチャとマネジメント

「次の案件にはどのフレームワークを採用しますか？」
「場合による」

選択することは簡単ではない．理由を説明する「責任」と，結果を受け入れる「覚悟」が必要．

何かを「選んだ」と思ったら，その理由を自身で説明できるか．

* コロケーションアジャイルの実践 - @matsudate
アジャイルなソフトウェア開発をするためには，円滑なコミュニケーションが必要不可欠なので，拠点が離れている場合はその部分をどうやって埋めるかに焦点が当たっている感じがしました．

最初は一緒の場所で働いていて，徐々に分離していくところや，離れていることを利用してチームの意気を上げるところは上手だなあと思いました．

以下はメモです

** 横浜と函館の拠点でアジャイルなソフトウェア開発をしているよ

- 企業のニーズ
  1. リスク分散・安価
  2. 品質・顧客満足
- 1 を目指す -> オフショア開発
- 2 を目指す -> アジャイル開発

| 種別           | 管理・責任 | 作業分担 | コミュニケーション |
| オフショア開発 | 独立       | 分割     | 疎                 |
| アジャイル開発 | 連帯       | 共有     | 密                 |

- ソフトウェア開発への信念
  - ソフトウェア開発はロケーションを選ばない
  - よいモノはよい環境とよい人材で作られる
  - よい人材はよい対偶でしかるべき
  - 信頼，安心を前提としてチームを構成

- Matt Simons "Internationally Agile" - The Challenges of Offshore Development
  - コミュニケーションの減少
  - 可視化の減少
  - 結合が大変
  - 見積感覚の相違

- Martin Fowler - "using an agile software process with offshore development"
  - 16 のポイントを挙げている

** 16 のポイントについて語っていく
*** 1. Continuous Integration
- 統合・統一テスト環境の整備
- テストの自動実行，継続実行

1番最初にやっておく

*** 2. Have Each Site Send Ambassadors to the Other Sites
- マネージャ，リーダの派遣，常駐
- コミュニケーションギャップを埋める

1. 一緒に作業
2. 近くだけど別の場所で作業
3. 函館へ移転して作業

*** 3. User Contact Visits to build trust
- Ambassadorsのみでは満足ではない
- ふたつのタイプ
  - プロジェクトの初期の関係・環境構築
  - タスクの実行，ふりかえり，計画変更時

試行錯誤の臨場感演出(コミュニケーションギャップを生まないように)

*** 4. Don't Underestimate the Culture Change
- アジャイルを導入する上で大きな障壁
- プロジェクト管理 = コントロールの科学 …なのか？

"autonomy is a great motivator, allowing people tobe productive and responsible"

函館チームのプライドを鼓舞

*** 5. Use wikis to contain common information
- Wikiの有効活用
- 連絡，記録，ガイドライン，指示，マネジメント

*** 6. Use Test Scripts to Help Understand the Requirements
- 要求仕様を明確化
- 正しく伝達されているかの確認

イテレーション開始直後のテスト仕様確定

必ずペアで作業する

*** 7. Use Regular Builds to Get Feedback on Functionality
- Feedbackの早期発見，対応漏れへの対処
- ユーザー教育

イテレーションリリース

*** 8. Use Regular Short Status Meetings
- 頻繁なスタンドアップミーティング

Skype朝会

持ちまわり一言

*** 9. Use Short Iterations
- 短かいサイクルのイテレーション開発

*** 10. Use an Iteration Planning Meeting that's Tailored for Remote Sites
- 遠隔地に適した計画ゲームへの準備

前イテレーション中に次開発要件をブレイクダウンするチームを結成

あらゆる通信手段を駆使(TV会議,電話,Skype,IPM...)

*** 11. When Moving a Code Base, Bug Fixing Makes a Good Start
- ソースコードの保守移管はBugfixから始めるのがよし

リファクタ，バグフィックスのみのイテレーションを実施

開発とは別ラインでのバグフィックス平行作業

*** 12. Separate teams by functionality not activity
- 工程ではなく機能によるチーム分担

*** 13. Expect to need more documents
- 必要なドキュメントは必要

自らが必要とするドキュメントは作成する

ドキュメントは間違ってることもある．必要なところだけ抜き出して新しく作ってもいいよ．

*** 14. Get multiple communication modes working early
- コミュニケーションツールの駆使

最初，プロジェクトの概要説明をビデオに撮っておいて，後からjoinした人に観せるとか

*** 15. Costs and Benefits of Offshore Development
- オフショアとコスト削減

"productivity differences between developers are far greater than salary differences"

*** 16. The Future of Offshore and Agile
- オフショア開発にアジャイルは適合するか

* テストコードのリファクタリング - @shuji_w6e
テストが増えてくると，テストの構造化やパラメタライズドテストは必要になりますよねえ．

テストをどこまでまとめてしまうかはそれぞれの利点/欠点があると思いますが，
僕の場合は，テストを見たとき，上下にあるテストと比べて，どこが違うのかを一目でわかる程度にはまとめますね．

テストコードをリファクタリングするくらいテストが増えてくると，
テストがすぐに終わらない，スローテスト問題というのも出てくるので，
そちらについても今度話を伺いたいなあと思いました．(実際に測ったベンチとかあれば)

以下はメモです

- 現代ソフトウェア開発の3本柱
  1. バージョン管理
  2. テスティング
  3. 自動化

** ユニットテストの目的
TDDのユニットテストの目的 -> 開発者の不安の解消

- ユニットテストとは
  - ソフトウェアを構成する最小部品のテスト
  - 対象が期待される振る舞いをするかを検証

ユニットテストはセーフティネット

- ユニットテストは品質に影響するのか？
  - 間接的には品質はあがる
    - その後の変更はしやすい
  - 直接の品質はあがらない
    - 例)仕様を勘違いしたまま，ユニットテストを書いて，それが通った
- ユニットテストは難しい
  - 習得するにはそれなりに書かなければいけない
  - テスト技法を学ぶ必要がある
  - テストを書くプロジェクトに参加する必要がある
  - チーム全体の意識改革が必要
- ユニットテストは簡単
  - 書けば書くほど身につけやすい
  - パターン化しやすい
- ユニットテストは有効
  - 積極的なリファクタリング
  - 安心感と自信
  - より良い設計
  - デグレードの防止
- ユニットテストを学習するコツ
  - たくさん書く
  - 書いて整理する
  - なんでも自動化する

** 書いて整理する
- プロダクションコードでのDRY原則とテストコードでのDRY原則は割合が異なる
  - テストコードにおいて重複を排除しすぎると可読性が落ちる

*** JUnitでのテスト整理の鍵
- カスタムMatcher,カスタムRule
- 構造化テスト
  - Enclosure を使う
- パラメータ化テスト
  - Theories を使う
- 複雑な条件なら
  - Cucumber を使ってもいいかもね
- 条件が複雑すぎて網羅できません！
  - テストケースを選択しよう
  - all pair 法
