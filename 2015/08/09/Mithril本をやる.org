* Mithril本をやる

[[http://www.oreilly.co.jp/books/9784873117447/][O'Reilly Japan - Mithril]] をやる．

なぜやろうと思ったか．

[[http://blog.shibu.jp/article/160479412.html][世界最速でMithril本をリリースした話]] を読んで，

#+begin_quote
趣味時間をすべて削って何かを学んでも、「100点」にはなりません。せいぜい、1つや2つに分野をしぼって、仕事時間も使い、たまには趣味時間も使ってフォーカスしてようやく1つや2つ語れるようになる、といったところ
#+end_quote

#+begin_quote
「がっつりフルタイムでウェブ技術を追いかける時間は取れないけど、今の仕事に取り入れるべく、なるべく新しく、ウリになりそうなもの(Mithrilは高速)を効率よく学んでおきたい」という人
#+end_quote

が僕のスキルセットで欠如しているクライアントサイドのツールのところにうまくハマりそうだなと思った．

- 必要だけどあんまり時間をかけたくなくない
- 複雑なことをやろうとはしていない

という状態なので，複雑さの増大を防止するような割り切りがあって，ドキュメントが整備されているツールが嬉しい．

** 1 章 GUIのパターンとMithrilの概要

「あなたが指している MVC ってどれですか？」という話は数年-十年くらい前に web で良く話されていたように思う．

「[[http://www.slideshare.net/snoozer05/next-generation-web-application-architecture][リッチクライアント時代のWebアプリケーションアーキテクチャパターンについて考える]]」というスライドで知識を整理させてもらったので，たまに見直すことがある．(よく忘れる)

#+begin_quote
他の物が3リッター以上のエンジンで車重2トンを超えるボディを引っ張る、
ベントレーコンチネンタルのようなラグジュアリーカー路線だとすると、
MithrilはCBR600RRか、Ninjaに例えることができます。
#+end_quote

この例えはちょっと笑ってしまった．
Ninja はバイクの中では重厚なイメージが僕にはあるけど，
CBR600RR のバイクの中でも軽くて速くて切れ味バツグンのイメージには沿いますね．

** 2 章 Mithrilチュートリアル

*** 2.1 最小限のMithrilアプリケーション

client/index.html で

#+begin_src html
  <script type="text/javascript" src="mithril.min.js"></script> <!-- (2) -->
  <script src="app.js"></script>                                <!-- (3) -->
#+end_src

となっているところ，一つめには =type= を宣言しているのに，二つめには =type= を宣言していないのはなぜなんだろう？

たぶん Mithril 関係ないけど，どうやって使い分けてるの？

*** 2.2 ToDoアプリケーションを作ってみる

=Todo = function(data) {= は =new Todo= したときに呼ばれるコンストラクタなのだよな．
久しく JavaScript をちゃんと書くことがなかったので忘れている．

=function view()= のところで =(1)= から =(5)= まで連番が振られている．文中には 1 と 2 しか出てきていないな．
番号が振られているところは説明があるのかなと思ったので戸惑った．

*** 2.3 ローカル保存機能を追加する

本とは関係ないのだけど typo していて最初全然動かなかった．ギギギ

[[https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/bind][Function.prototype.bind() - JavaScript | MDN]]

=bind= は，呼び出す関数の中にある =this= が指すオブジェクトを外部から渡してやるためのもの．

=vm.check.bind(task)= は
「 =vm.check= という関数を呼び出す，そのとき =vm.check= の中に書いてある =this= は =task= で渡したものとする」
ということだ．

使い慣れていないから出てくると気をつけて読まないと間違えそうになる．

*** 2.4 サーバ保存機能を追加する

#+begin_quote
m.request()関数はm.prop()で作成するのと同じプロパティのインタフェースを持つオブジェクトを返します。
通信が完了すると取得してきたデータが代わりに入ります。
MithrilはAJAXの通信終了を待って自動で再描画を行うので、通信完了時に何かをする必要はありません。
#+end_quote

なるほど．サーバーと通信するなら =m.request= を使えばいいのだな．

*** 2.5 本章のまとめ

#+begin_quote
・Mithrilではコンポーネントを作成し、m.mount()で登録する。
・コンポーネントにはcontroller()とview()という2つの関数がある。
・Mithrilでは、フレームワーク固有のベースクラスなどは要求されない。モデルも素のJavaScriptのままのクラス。
・モデルの主要な部品はm.prop()で作成するプロパティ。
・ビューモデルが、ビューとモデルの仲介をする。入力テキストなど、ビューの一時的な状態はビューモデルが持つ。
・テンプレートはm()関数を使って、JavaScriptで組み立てる。
・ビューへのバインディングはプロパティを渡せば行える。ビューからのバインディングはm.withAttr()を使う。
・サーバとの通信はm.request()で、これを使えば再描画システムとの調整も不要。
#+end_quote

なるほど．

** 3 章 Mithrilのコントローラ、モデル、ビューモデル

*** 3.1 コントローラ

オブジェクトの寿命を知ると大体の役割もみえてくる．

#+begin_quote
コントローラはコンストラクタ関数としてコンポーネントと同じ寿命を持つオブジェクトを作るのに使われるため、コントローラもページと同じ期間だけ生存します。
#+end_quote

**** 3.1.1 コントローラが扱うデータ

基本

- ビューモデルやモデルの参照を取ってくることだけ
- コントローラからアプリケーションのデータへの直接アクセスは非推奨

その他

- ページ内で使われる特別なイベント登録と解除
- アプリケーション内で一番粒度の大きい、ページそのものの状態

**** 3.1.2 コントローラの実装

- controller に指定する関数は JavaScript のコンストラクタ関数と同じ動き
  - =return= をつけないと，自身のオブジェクトを返す
  - =return= で自身ではないオブジェクトを返すこともできる
- コントローラがない時は、空の関数が指定されたものとして動作する
- [m.route()] -> m.mount() -> コントローラのインスタンス作成
- 他にオブジェクト類を生成すべきエントリポイントはない
- view関数は再描画が行われるたびに呼び出される．つまり最大で毎秒60回呼ばれるのでオブジェクト初期化には的さない

**** 3.1.3 後片付け処理

- =onunload= メソッドを登録しておくと，コンポーネントがアンロードされるときに呼び出される
- =onunload= で =preventDefault= すればアンロードを中断できる

コンポーネントのアンロードは，だいたいページ遷移と同じと考えておこう．


*** 3.2 モデル

#+begin_quote
アプリケーションが扱う領域のデータと手続き（ビジネスロジック -ショッピングの合計額や送料を計算するなど）を表現する要素
#+end_quote

**** 3.2.1 Mithrilのモデルのインタフェース

- インスタンスを作る時は、JavaScriptのオブジェクトを引数として受け取れるようにする
- プロパティには、m.prop()を指定する
- Mithrilはモデルが変更されても「何もしない」

**** 3.2.2 コンストラクタ

- =m.request= の結果が配列なら，配列の各要素を初期値として =new= する．配列ではないなら，それを初期値として =new= する
- =m.request= の =type= 経由でアクセスしないなら，コンストラクタ引数から初期化するインタフェースを満たす必要はない
- オブジェクトのプロパティは全て =m.prop= でラップする

**** 3.2.3 セッター・ゲッター

- =m.prop= は引数があれば setter 引数がなければ getter として働く
- プロパティは 1 つの引数を持つ関数という形式であれば，自作でも問題なく動く

**** 3.2.4 非同期アクセス

- =m.request= の返り値も =m.prop= 形式である
- =m.request= に =initialValue= を設定しておくと， =undefined= のチェックが不要でコードが簡潔になることがある

ヌルオブジェクトパターンだ

**** 3.2.5 モデルの永続化

- Mithrilの永続化に関する機能は JSON の読み書きだけ
- =m.prop= は =toJSON()= インタフェースを用意しているので，凝ったことをしなければそのまま使える

**** 3.2.6 モデルのライフサイクルと名前空間

- モデルは他のコンポーネントよりも寿命が長いことを前提
- コントローラーと寿命を同期させると，ページ遷移の都度モデルも作り直すことになる(=サーバーアクセスが必要になる)
- 不要なサーバーアクセスを避けるため，シングルトンパターンを使うのを推奨
  - 必要になったタイミングで初期化を行う
  - ブラウザがページを表示している限り存続させる

*** 3.3 ビューモデル

- ビューとモデルの中継をするレイヤー

ビューモデルの役割

#+begin_quote
1. ビューの一時的な状態を保持するプロパティの保持
2. ビューで定義するテンプレートから呼び出されるイベントハンドラの実装
3. モデルへの参照を保持しておいて、ビューから参照しやすいようなアクセスメソッドを提供
#+end_quote

例

#+begin_src javascript
var vm = {
    init: function () {
        vm.list = m.prop([]);        // 3. モデルへの参照を保持しておいて、ビューから参照しやすいようなアクセスメソッドを提供
        vm.description = m.prop(""); // 1. ビューの一時的な状態を保持するプロパティの保持 (ビューでこの関数がバインドされる)
        vm.add = function () {       // 2. ビューで定義するテンプレートから呼び出されるイベントハンドラの実装
            if (vm.description()) {
                vm.list().push(new Todo({description: vm.description()}));
                vm.description("");
            }
        };
    }
};
#+end_src

**** 3.3.1 ビューモデルはコンポーネントの中？外？

どちらでもかまわない．

ただし，コンポーネントの中に置くと，ページ移動のたびに破棄されたり生成されたりする．

寿命をページより長く保ちたい場合は外に置くこと．

*** 3.4 MithirlのAPIとレイヤー分けの目安

表3-1 を転載．

|                                                    | M | V | C | VM |
| m()/m.withAttr()/m.trust()/m.component()           | X | O | X | X  |
| m.prop()                                           | O | X | X | O  |
| m.route()                                          | X | X | O | X  |
| m.request()                                        | O | X | X | X  |
| m.deferred()/m.sync()                              | O | X | O | O  |
| m.redraw()/m.startComputation()/m.endComputation() | O | X | O | X  |

大きな規模だとこんな感じで使い所を分けるとよいそうだ．

*** 3.5 大きなアプリケーションのファイル分割構成

横(model/controller/viewといったレイヤー)単位ではなく，縦(機能/コンポーネント)単位で分けるのを推奨している．

これはその方が僕も好きだ．

*** 3.6 本章のまとめ

#+begin_quote
Mithrilがどのようなアーキテクチャでアプリケーションを実装して欲しいと考えているか説明
#+end_quote

- コントローラ :: 寿命はページと同じ．ビューモデルやモデルの参照を保持する
- モデル :: 寿命はページより長い．コンストラクタにはオブジェクトを受け取れるようにしておく．プロパティは =m.prop= でラップしておく．
- ビューモデル :: 寿命は(基本的に)ページと同じ．一時的な状態の保持/テンプレートからのイベントハンドラ/便利なアクセスメソッドの3つの役割．
